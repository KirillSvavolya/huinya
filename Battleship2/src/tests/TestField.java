package tests;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import model.Field;
import model.ExceptionCollections.IllegalCoordinateException;

public class TestField {
	Field field;
	int[][] board;
	ArrayList<Integer> arrayList = new ArrayList<Integer>();
	public static final char[] letters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'}; 
	
	@BeforeEach
	public void setup() {
		field = new Field();
	}
	
	@Test
	public void testIfAllShipsPlacedBySum() {
		// place ships
		field.placeShips();
		// retrieve the final board in the form of int[][].
		board = field.getBoard();
		// Setup the counter for sum.
		int sum = calculateSum(this.board);
		// Check whether the sum of placed sums is equal to the number of total
		// cells expected.
		assertEquals(63, sum);
	}
	
	// Test if all of the ships were placed by recreating an array of ships from the board.
	@Test
	public void testIfAllShipsPlacedByComparison() {
		// place ships and get the board.
		int[] newArr;
		field.placeShips();
		board = field.getBoard();
		// reconstruct ships collection from the board.
		newArr = reconstructShipArray(board);
		Arrays.sort(newArr);
		
		// Test if the recreated list is equal to the original one.
		assertTrue(Arrays.equals(Field.ships, newArr));
	}
	
	// Test whether the arrayList generated by picking random ships in the class is the same as initial list.
	@Test
	public void testRandomShipGetter() {
		// Create resultant list.
		int[] finalShipArr = new int[Field.ships.length];
		// loop through each ship required to be placed and add it to the arrayList.
		for (int ship: Field.ships) {
			this.arrayList.add(ship);
		}
		// pick random ship from the arrayList 28 times and add to the resultant array.
		for (int i = 0; i < 28; i++) {
			finalShipArr[i] = field.getRandomShip(this.arrayList);
		}
		
		// Check whether arrays differ - brief check if the elements are picked on random basis.
		assertFalse(finalShipArr.equals(Field.ships));
		
		// Check if the arrays have identical content when sorted.
		Arrays.sort(finalShipArr);
		assertTrue(Arrays.equals(finalShipArr, Field.ships));
	}
	
	// Test whether ships do not intersect horizontally.
	@Test
	public void testHorizontallIntersection() {
		for (int k = 0; k < 100; k++) {
			field = new Field();
			field.placeShips();
			board = field.getBoard();
			int size = 0;
			for(int i = 0; i < board.length; i++) {
				for (int j = 0; j < board.length; j++) {
					while(board[i][j] == 1) {
						size++;
						j++;
						if (j == 14) {
							break;
						}
					}
					assertTrue(size >= 0 && size <= 5);
					assertEquals(63, calculateSum(board));
					size = 0;
				}
				
			}
		}
	}
	
	// Test if the "reconstruction" method works.
	@Test
	public void testReconstructionAlgorithm() {
		board = new int[][] {
			{1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0},
			{1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0},
			{1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1},
			{1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1},
			{1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1},
			{1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}	
		};
		int[] newArr = reconstructShipArray(board);
		Arrays.sort(newArr);
		assertArrayEquals(Field.ships, newArr);
	}
	
	// Calculates sum of the elements on the board.
	private int calculateSum(int[][] board) {
		// Setup the counter for sum.
		int sum = 0;
		// count whether the number of placed cells.
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				if (board[i][j] == 1) {
					sum++;
				}
			}
		}
		return sum;
	}
	
	private int[] reconstructShipArray(int[][] board) {
		// setup counter to recreate a ship from it's cells.
		int size = 0;
		// create a list to populate.
		int[] list = new int[Field.numberOfShips];
		// setup index to add elements to the array.
		int index = 0;
		// Recreate the array.
		for(int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				// find the first element equal to 1.
				if (board[i][j] == 1) {
					// check each next cell and increment the counter until either the end
					// of the row is reached or the ship ends (0 is found).
					while (board[i][j] == 1) {
						size++;
						// Check for the end of the row.
						if (j == board[i].length - 1) {
							break;
						} else {
							// Move to the next cell.
							j++;
						}
					}
					// Add ship to the array.
					list[index] = size;
					// set size equal to 0 (for the next ship).
					size = 0;
					// move to the next position in the recreated array.
					index++;
				}	
			}
		}
		return list;
	}
	
	// Test if the method which translates String of coordinates into indices works.
	@Test
	public void testCoordinateSeparation() {
		field.placeShips();
		board = field.getBoard();
		int[] result;
		String toBreak = "";
		for(int i = 0; i < board.length; i++) {
			for (int j = 0; j < letters.length; j++) {
				toBreak = String.format("%d%s", i, letters[j]);
				try {
					result = field.breakCoordinates(toBreak);
					assertArrayEquals(new int[] {i, j}, result);
				} catch (IllegalCoordinateException e) {
					e.printStackTrace();
				}
				
			}
		}
	}
	
	@Test
	public void testShooting() {
		field.placeShips();
		board = field.getBoard();
		int[][] copy = copyTheArray(board);
		// shoot in every cell.
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < letters.length; j++) {
				try {
					field.shoot(String.format("%d%s", i, letters[j]));
				} catch (IllegalCoordinateException e) {
					e.printStackTrace();
				}
			}
		}
		
		// fill the copy to compare.
		for (int i = 0; i < copy.length; i++) {
			for (int j = 0; j < copy[0].length; j++) {
				if (copy[i][j] == 0) {
					copy[i][j] = 3; // 3 indicates miss.
				} else {
					copy[i][j] = 2; // 2 indicates dead cell.
				}
			}
		}
		assertArrayEquals(copy, board);
		
	}
	
	private int[][] copyTheArray(int[][] arr) {
		int[][] res = new int[arr.length][arr[0].length];
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr[0].length; j++) {
				res[i][j] = arr[i][j];
			}
		}
		return res;
	}
}
